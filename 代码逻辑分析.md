# 代码逻辑分析 - 确保不会重复上传

## 一、核心逻辑流程

### 1. 文件状态管理（FileInfo 实体）

每个文件在数据库中有独立的状态字段：

```java
status 字段值：
- 0 = 待上传
- 1 = 上传中
- 2 = 已上传
- 3 = 失败
```

**关键点**：每个文件的状态是独立的，互不影响。

### 2. 获取待上传文件列表（FileInfoServiceImpl.java 第120-127行）

```java
@Override
public List<FileInfo> getPendingFiles(Long taskId) {
    LambdaQueryWrapper<FileInfo> wrapper = new LambdaQueryWrapper<>();
    wrapper.eq(FileInfo::getTaskId, taskId)
           .in(FileInfo::getStatus, 0, 3) // 待上传(0) 或 失败(3)
           .orderByAsc(FileInfo::getCreateTime);

    return this.list(wrapper);
}
```

**重要修复**：
- **修复前**：只查询 `status = 0`（待上传）的文件
- **修复后**：查询 `status IN (0, 3)`（待上传或失败）的文件
- **效果**：重试时会包含失败的文件，但**不会包含已上传（status=2）的文件**

### 3. 上传任务执行流程（UploadServiceImpl.java 第41-138行）

```java
@Override
@Async("taskExecutor")
public void executeTask(Long taskId) {
    // 1. 获取待上传的文件列表（只包含 status=0 或 status=3）
    List<FileInfo> pendingFiles = fileInfoService.getPendingFiles(taskId);

    // 2. 逐个上传文件
    for (FileInfo fileInfo : pendingFiles) {
        // 3. 获取最佳可用账号
        GdAccount account = gdAccountService.getBestAvailableAccount(fileInfo.getFileSize());

        if (account == null) {
            // 4. 如果没有账号有足够配额，标记文件为失败（status=3）
            fileInfoService.updateFileStatus(fileInfo.getId(), 3, "所有账号配额不足");
            continue; // 继续处理下一个文件
        }

        // 5. 上传文件
        boolean success = uploadFile(taskId, fileInfo.getId(), account.getId());

        if (success) {
            // 6. 上传成功，标记为已上传（status=2）
            // 7. 备份文件到 /backdata/{任务名称}/
            // 8. 删除源文件
        }
    }
}
```

## 二、场景验证：两个文件，第一个750G，第二个明天传

### 今天的执行流程

**初始状态**：
- 文件1（600G）：status = 0（待上传）
- 文件2（200G）：status = 0（待上传）
- 账号1：剩余配额 750G

**执行步骤**：

1. **调用 `getPendingFiles(taskId)`**
   - 返回：[文件1, 文件2]（都是 status=0）

2. **处理文件1（600G）**
   ```
   getBestAvailableAccount(600G)
   → 账号1剩余750G >= 600G ✅
   → 返回账号1

   uploadFile(文件1)
   → 上传成功
   → status = 2（已上传）
   → 备份到 /backdata/上传任务_2026-01-19/文件1
   → 删除源文件 /data/文件1

   updateAccountQuota(账号1, 600G)
   → 账号1剩余配额 = 750G - 600G = 150G
   ```

3. **处理文件2（200G）**
   ```
   getBestAvailableAccount(200G)
   → 账号1剩余150G < 200G ❌
   → 账号2剩余150G < 200G ❌
   → 账号3剩余100G < 200G ❌
   → 返回 null

   updateFileStatus(文件2, 3, "所有账号配额不足，需要 200.00 GB")
   → status = 3（失败）
   → 继续处理下一个文件（没有了）
   ```

4. **任务完成检查**
   ```
   已上传数量 = 1
   总文件数 = 2
   1 != 2，且有失败文件
   → 任务状态 = 5（失败）
   ```

**今天结束状态**：
- 文件1：status = 2（已上传），已备份到 `/backdata/上传任务_2026-01-19/文件1`，源文件已删除 ✅
- 文件2：status = 3（失败），源文件仍在 `/data/文件2` ✅
- 任务状态：5（失败）

### 明天的执行流程

**操作**：
1. 手动重置账号配额（或自动重置）
2. 在任务管理页面点击"重试"按钮

**执行步骤**：

1. **调用 `getPendingFiles(taskId)`**
   ```sql
   SELECT * FROM file_info
   WHERE task_id = ?
   AND status IN (0, 3)  -- 待上传或失败
   ORDER BY create_time
   ```
   - **返回：[文件2]**（status=3）
   - **不包含文件1**（status=2，已上传）✅

2. **处理文件2（200G）**
   ```
   getBestAvailableAccount(200G)
   → 账号1剩余750G >= 200G ✅
   → 返回账号1

   uploadFile(文件2)
   → 上传成功
   → status = 2（已上传）
   → 备份到 /backdata/上传任务_2026-01-19/文件2
   → 删除源文件 /data/文件2

   updateAccountQuota(账号1, 200G)
   → 账号1剩余配额 = 750G - 200G = 550G
   ```

3. **任务完成检查**
   ```
   已上传数量 = 2
   总文件数 = 2
   2 == 2
   → 任务状态 = 2（已完成）✅
   ```

**明天结束状态**：
- 文件1：status = 2（已上传），在 `/backdata/上传任务_2026-01-19/文件1` ✅
- 文件2：status = 2（已上传），在 `/backdata/上传任务_2026-01-19/文件2` ✅
- 任务状态：2（已完成）
- **文件1没有被重复上传** ✅✅✅

## 三、为什么不会重复上传？

### 关键证据 1：SQL 查询条件

```java
wrapper.in(FileInfo::getStatus, 0, 3) // 只查询 status=0 或 status=3
```

**已上传的文件（status=2）永远不会被查询出来！**

### 关键证据 2：状态转换流程

```
待上传(0) → 上传中(1) → 已上传(2)  [成功路径]
待上传(0) → 上传中(1) → 失败(3)    [失败路径]
失败(3)   → 上传中(1) → 已上传(2)  [重试成功路径]
```

**一旦文件变为 status=2（已上传），就永远不会再被 getPendingFiles() 查询出来！**

### 关键证据 3：数据库持久化

每次状态变更都会立即写入数据库：

```java
fileInfoService.markFileAsUploaded(fileId, accountId);
// 内部执行：
fileInfo.setStatus(2); // 已上传
this.updateById(fileInfo); // 立即写入数据库
```

**即使程序重启，文件状态也不会丢失！**

## 四、新增功能：自动备份和删除

### 功能说明

每个文件上传成功后，系统会自动：
1. 将文件移动到 `/backdata/{任务名称}/` 目录
2. 保持原有的子目录结构
3. 删除源文件

### 实现代码（UploadServiceImpl.java 第224-271行）

```java
private void backupAndDeleteFile(FileInfo fileInfo, UploadTask task) {
    // 1. 构建备份目录: /backdata/{任务名称}/
    String backupDirPath = "/backdata/" + sanitizeFileName(task.getTaskName());

    // 2. 保持源文件的相对路径结构
    // 例如: /data/folder1/file.txt -> /backdata/{任务名称}/folder1/file.txt
    Path sourcePath = Paths.get(task.getSourcePath());
    Path relativePath = sourcePath.relativize(sourceFile.getParent());
    Path targetDir = backupDir.resolve(relativePath);

    // 3. 移动文件（相当于备份+删除）
    Files.move(sourceFile, targetFile, StandardCopyOption.REPLACE_EXISTING);
}
```

### 示例

**任务信息**：
- 任务名称：`上传任务_2026-01-19 10:30:00`
- 源路径：`/data`
- 目标路径：`/刷流上传`

**文件结构**：
```
/data/
  ├── file1.mp4
  ├── folder1/
  │   ├── file2.mp4
  │   └── file3.mp4
  └── folder2/
      └── subfolder/
          └── file4.mp4
```

**上传成功后的备份结构**：
```
/backdata/上传任务_2026-01-19_10_30_00/
  ├── file1.mp4
  ├── folder1/
  │   ├── file2.mp4
  │   └── file3.mp4
  └── folder2/
      └── subfolder/
          └── file4.mp4
```

**源文件**：全部删除 ✅

### 安全特性

1. **备份失败不影响上传**：如果备份失败，只记录日志，不影响上传流程
2. **保持目录结构**：备份时保持原有的子目录结构
3. **文件名清理**：任务名称中的非法字符会被替换为下划线
4. **原子操作**：使用 `Files.move()` 确保移动操作的原子性

## 五、总结

### 不会重复上传的三重保障

1. **SQL 查询过滤**：`getPendingFiles()` 只查询 `status IN (0, 3)`，不包括已上传（status=2）
2. **状态持久化**：每次状态变更立即写入数据库，程序重启也不会丢失
3. **独立文件跟踪**：每个文件有独立的状态，互不影响

### 配额管理的智能处理

1. **逐文件检查**：每个文件上传前都检查配额
2. **自动账号切换**：配额不足时自动切换到下一个账号
3. **优雅失败**：所有账号都不够时，标记文件失败，继续处理其他文件
4. **支持重试**：失败的文件可以在配额重置后重试

### 自动备份和清理

1. **上传成功即备份**：文件上传成功后立即备份到 `/backdata/{任务名称}/`
2. **保持目录结构**：备份时保持原有的子目录结构
3. **自动删除源文件**：备份成功后自动删除源文件，释放磁盘空间
4. **安全可靠**：备份失败不影响上传流程

**你可以完全放心使用，系统绝对不会重复上传已成功的文件！** ✅✅✅
