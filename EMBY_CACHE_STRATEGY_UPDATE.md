# Emby 缓存策略更新说明

## 修改概述

将 Emby 管理模块的缓存策略从"按需加载+缓存"改为"一次性全量同步到数据库"。

## 修改前的逻辑

### 旧策略：按需加载 + 懒加载缓存

1. **首次访问**：从 Emby API 获取数据，然后保存到数据库缓存
2. **后续访问**：优先从数据库缓存读取
3. **强制刷新**：通过 `forceRefresh=true` 参数重新从 API 获取

**问题**：
- 首次访问每个接口都需要调用 Emby API，响应慢
- 数据分散加载，不利于整体数据管理
- 缓存更新策略复杂，容易出现数据不一致

## 修改后的逻辑

### 新策略：一次性全量同步 + 数据库查询

1. **初始化**：调用 `/api/emby/sync` 接口，一次性全量同步所有数据到数据库
2. **所有查询**：直接从数据库读取，不再调用 Emby API
3. **数据更新**：需要时重新调用 `/api/emby/sync` 接口全量同步

**优势**：
- 所有查询都从数据库读取，响应速度快
- 数据一致性好，统一管理
- 逻辑简单清晰，易于维护
- 减少对 Emby 服务器的频繁请求

## 修改的文件

### 1. `EmbyCacheServiceImpl.java`

#### 修改的方法：

- `getAllLibraries()` - 直接从数据库获取媒体库列表
- `getLibraryItemsPaged()` - 直接从数据库分页获取媒体项
- `getItemDetail()` - 直接从数据库获取媒体项详情
- `searchItems()` - 直接在数据库中搜索
- `getAllGenres()` - 直接从数据库获取类型列表
- `getAllTags()` - 直接从数据库获取标签列表
- `getAllStudios()` - 直接从数据库获取工作室列表

#### 新增/优化的方法：

- `syncAllData()` - 优化为一次性全量同步，包含详细日志
- `syncLibraryItemsAll()` - 新增全量同步单个媒体库的方法，支持进度显示
- `syncLibrary()` - 优化为先删除旧数据，再全量同步

### 2. `IEmbyCacheService.java`

更新接口文档注释，说明 `forceRefresh` 参数已废弃，保留仅为兼容性。

### 3. `EmbyController.java`

更新所有接口的注释，说明：
- 所有查询接口都从数据库读取
- 首次使用前需要先调用 `/api/emby/sync` 接口同步数据
- `forceRefresh` 参数已废弃

## 使用方式

### 1. 首次使用

```bash
# 调用同步接口，一次性全量同步所有数据
POST /api/emby/sync
```

**响应示例**：
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "success": true,
    "totalLibraries": 5,
    "totalItems": 1234,
    "totalGenres": 45,
    "totalTags": 67,
    "totalStudios": 89,
    "duration": "120秒"
  }
}
```

### 2. 查询数据

同步完成后，所有查询接口都直接从数据库读取：

```bash
# 获取媒体库列表
GET /api/emby/libraries

# 获取媒体项（分页）
GET /api/emby/libraries/{libraryId}/items/paged?startIndex=0&limit=50

# 搜索媒体项
GET /api/emby/search?keyword=电影

# 获取类型列表
GET /api/emby/genres

# 获取标签列表
GET /api/emby/tags

# 获取工作室列表
GET /api/emby/studios
```

### 3. 更新数据

当 Emby 服务器数据有更新时，重新调用同步接口：

```bash
# 全量同步所有数据（会清空旧数据）
POST /api/emby/sync
```

### 4. 清空缓存

```bash
# 清空所有数据库缓存
POST /api/emby/cache/clear
```

## 同步过程说明

### 同步流程

1. **清空旧数据**：删除数据库中的所有旧缓存数据
2. **同步媒体库列表**：获取所有媒体库并保存到数据库
3. **同步媒体项**：遍历每个媒体库，全量获取所有媒体项
   - 每次获取 100 条
   - 批量保存到数据库
   - 显示同步进度
4. **同步元数据**：获取并保存类型、标签、工作室信息
5. **返回统计结果**：返回同步的数据量和耗时

### 日志示例

```
========================================
开始一次性全量同步所有Emby数据到数据库
========================================
步骤1: 清空旧数据...
旧数据已清空
步骤2: 同步媒体库列表...
从Emby API获取到 5 个媒体库
媒体库列表已保存到数据库
步骤3: 同步所有媒体库的媒体项...
正在同步媒体库 [1/5]: 电影 (ID: xxx)
开始全量同步媒体库 xxx 的所有媒体项
获取第 1 批数据 (startIndex=0, limit=100)
保存第 1 批数据到数据库，共 100 条
同步进度: 100/1234 (8%)
获取第 2 批数据 (startIndex=100, limit=100)
...
媒体库 电影 全量同步完成，共 1234 个媒体项
步骤4: 同步类型、标签、工作室...
同步 45 个类型
同步 67 个标签
同步 89 个工作室
========================================
全量同步完成！
媒体库: 5 个
媒体项: 1234 个
类型: 45 个
标签: 67 个
工作室: 89 个
耗时: 120 秒
========================================
```

## 数据库表结构

### 涉及的表

- `emby_library_cache` - 媒体库缓存
- `emby_item_cache` - 媒体项缓存
- `emby_genre_cache` - 类型缓存
- `emby_tag_cache` - 标签缓存
- `emby_studio_cache` - 工作室缓存

### 关键字段

- `id` - 主键（对应 Emby 的 ID）
- `last_sync_time` - 最后同步时间
- `json_data` - JSON 格式的完整数据（部分表）

## 性能优化建议

### 1. 定期同步

建议设置定时任务，定期同步数据（如每天凌晨）：

```java
@Scheduled(cron = "0 0 2 * * ?") // 每天凌晨2点
public void scheduledSync() {
    log.info("开始定时同步Emby数据");
    cacheService.syncAllData();
}
```

### 2. 增量同步（未来优化）

对于大型媒体库，可以考虑实现增量同步：
- 记录上次同步时间
- 只同步有变化的数据
- 减少同步耗时

### 3. 数据库索引

确保关键字段有索引：
- `parent_id` - 用于按媒体库查询
- `name` - 用于搜索
- `original_title` - 用于搜索
- `last_sync_time` - 用于排序

## 兼容性说明

### 保留的参数

所有接口的 `forceRefresh` 参数都保留，但已废弃：
- 传入 `true` 或 `false` 都不影响行为
- 所有查询都直接从数据库读取
- 保留参数仅为前端兼容性

### 前端无需修改

前端代码无需修改，只需：
1. 在应用启动时或首次访问时调用 `/api/emby/sync`
2. 后续正常调用查询接口即可

## 注意事项

1. **首次同步耗时**：根据媒体库大小，首次同步可能需要几分钟到几十分钟
2. **数据库空间**：需要足够的数据库空间存储所有媒体项数据
3. **事务管理**：同步过程使用事务，失败会自动回滚
4. **并发控制**：建议同一时间只执行一次同步操作

## 测试建议

### 1. 功能测试

```bash
# 1. 测试同步
POST /api/emby/sync

# 2. 测试查询媒体库
GET /api/emby/libraries

# 3. 测试查询媒体项
GET /api/emby/libraries/{libraryId}/items/paged?startIndex=0&limit=10

# 4. 测试搜索
GET /api/emby/search?keyword=test

# 5. 测试清空缓存
POST /api/emby/cache/clear

# 6. 再次同步
POST /api/emby/sync
```

### 2. 性能测试

- 测试不同大小媒体库的同步耗时
- 测试查询响应时间（应该在毫秒级）
- 测试并发查询性能

## 总结

这次修改将 Emby 缓存策略从"按需加载"改为"全量同步"，带来以下好处：

✅ **性能提升**：所有查询都从数据库读取，响应速度快
✅ **逻辑简化**：不再需要复杂的缓存更新逻辑
✅ **数据一致**：统一管理，避免数据不一致
✅ **易于维护**：代码更清晰，易于理解和维护
✅ **减少API调用**：减少对 Emby 服务器的频繁请求

唯一的代价是需要定期执行全量同步，但这可以通过定时任务在低峰期自动完成。
